import abc
from cf_units import Unit
import iris.util
from abc import ABCMeta, abstractmethod
from collections import namedtuple
from collections.abc import Iterator
from iris._data_manager import DataManager as DataManager
from iris.common import AncillaryVariableMetadata as AncillaryVariableMetadata, BaseMetadata as BaseMetadata, CFVariableMixin as CFVariableMixin, CellMeasureMetadata as CellMeasureMetadata, CoordMetadata as CoordMetadata, DimCoordMetadata as DimCoordMetadata, metadata_manager_factory as metadata_manager_factory
from typing import Any, Optional


class _DimensionalMetadata(CFVariableMixin, metaclass=ABCMeta):
    standard_name: str = ...
    long_name: str = ...
    var_name: str = ...
    units: Unit = ...
    attributes: Any = ...
#     @abstractmethod
#     def __init__(self, values: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., attributes: Optional[Any] = ...) -> Any: ...
#     def __getitem__(self, keys: Any): ...
#     def copy(self, values: Optional[Any] = ...): ...
#     @abstractmethod
#     def cube_dims(self, cube: Any) -> Any: ...
#     def __eq__(self, other: Any) -> Any: ...
#     def __ne__(self, other: Any) -> Any: ...
#     def __hash__(self) -> Any: ...
#     def __binary_operator__(self, other: Any, mode_constant: Any): ...
#     def __add__(self, other: Any): ...
#     def __sub__(self, other: Any): ...
#     def __mul__(self, other: Any): ...
#     def __div__(self, other: Any): ...
#     def __truediv__(self, other: Any): ...
#     def __radd__(self, other: Any): ...
#     def __rsub__(self, other: Any): ...
#     def __rdiv__(self, other: Any): ...
#     def __rtruediv__(self, other: Any): ...
#     def __rmul__(self, other: Any): ...
#     def __neg__(self): ...
#     bounds: Any = ...
#     def convert_units(self, unit: Any): ...
#     def is_compatible(self, other: Any, ignore: Optional[Any] = ...): ...
#     @property
#     def dtype(self): ...
#     @property
#     def ndim(self): ...
#     def has_bounds(self): ...
#     @property
#     def shape(self): ...
#     def xml_element(self, doc: Any): ...

class AncillaryVariable(_DimensionalMetadata): ...
#     def __init__(self, data: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., attributes: Optional[Any] = ...) -> None: ...
#     @property
#     def data(self): ...
#     @data.setter
#     def data(self, data: Any) -> None: ...
#     def lazy_data(self): ...
#     def core_data(self): ...
#     def has_lazy_data(self): ...
#     def cube_dims(self, cube: Any): ...

class CellMeasure(AncillaryVariable): ...
#     def __init__(self, data: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., attributes: Optional[Any] = ..., measure: Optional[Any] = ...) -> None: ...
#     @property
#     def measure(self): ...
#     @measure.setter
#     def measure(self, measure: Any) -> None: ...
#     def cube_dims(self, cube: Any): ...
#     def xml_element(self, doc: Any): ...

class CoordExtent: ...
#     def __new__(cls, name_or_coord: Any, minimum: Any, maximum: Any, min_inclusive: bool = ..., max_inclusive: bool = ...): ...

# POINT_MODE: int
# BOUND_MODE: int
# BOUND_POSITION_START: int
# BOUND_POSITION_MIDDLE: float
# BOUND_POSITION_END: int

# _GroupbyItem = namedtuple('GroupbyItem', 'groupby_point, groupby_slice')

class Cell: ...
#     __array_priority__: int = ...
#     def __new__(cls, point: Optional[Any] = ..., bound: Optional[Any] = ...): ...
#     def __mod__(self, mod: Any): ...
#     def __add__(self, mod: Any): ...
#     def __hash__(self) -> Any: ...
#     def __eq__(self, other: Any) -> Any: ...
#     def __ne__(self, other: Any) -> Any: ...
#     def __common_cmp__(self, other: Any, operator_method: Any): ...
#     def __ge__(self, other: Any) -> Any: ...
#     def __le__(self, other: Any) -> Any: ...
#     def __gt__(self, other: Any) -> Any: ...
#     def __lt__(self, other: Any) -> Any: ...
#     def contains_point(self, point: Any): ...

class Coord(_DimensionalMetadata, metaclass=abc.ABCMeta): ...
#     @abstractmethod
#     def __init__(self, points: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., bounds: Optional[Any] = ..., attributes: Optional[Any] = ..., coord_system: Optional[Any] = ..., climatological: bool = ...) -> Any: ...
#     def copy(self, points: Optional[Any] = ..., bounds: Optional[Any] = ...): ...
#     @classmethod
#     def from_coord(cls, coord: Any): ...
#     @property
#     def points(self): ...
#     @points.setter
#     def points(self, points: Any) -> None: ...
#     @property
#     def bounds(self): ...
#     @bounds.setter
#     def bounds(self, bounds: Any) -> None: ...
#     @property
#     def coord_system(self): ...
#     @coord_system.setter
#     def coord_system(self, value: Any) -> None: ...
#     @property
#     def climatological(self): ...
#     @climatological.setter
#     def climatological(self, value: Any) -> None: ...
#     def lazy_points(self): ...
#     def lazy_bounds(self): ...
#     def core_points(self): ...
#     def core_bounds(self): ...
#     def has_lazy_points(self): ...
#     def has_lazy_bounds(self): ...
#     def __hash__(self) -> Any: ...
#     def cube_dims(self, cube: Any): ...
#     def convert_units(self, unit: Any) -> None: ...
#     def cells(self): ...
#     def is_contiguous(self, rtol: float = ..., atol: float = ...): ...
#     def contiguous_bounds(self): ...
#     def is_monotonic(self): ...
#     def is_compatible(self, other: Any, ignore: Optional[Any] = ...): ...
#     @property
#     def bounds_dtype(self): ...
#     @property
#     def nbounds(self): ...
#     def has_bounds(self): ...
#     def cell(self, index: Any): ...
#     def collapsed(self, dims_to_collapse: Optional[Any] = ...): ...
#     def guess_bounds(self, bound_position: float = ...) -> None: ...
#     def intersect(self, other: Any, return_indices: bool = ...): ...
#     def nearest_neighbour_index(self, point: Any): ...
#     def xml_element(self, doc: Any): ...

class DimCoord(Coord): ...
#     @classmethod
#     def from_regular(cls, zeroth: Any, step: Any, count: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., attributes: Optional[Any] = ..., coord_system: Optional[Any] = ..., circular: bool = ..., climatological: bool = ..., with_bounds: bool = ...): ...
#     def __init__(self, points: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., bounds: Optional[Any] = ..., attributes: Optional[Any] = ..., coord_system: Optional[Any] = ..., circular: bool = ..., climatological: bool = ...) -> None: ...
#     def __deepcopy__(self, memo: Any): ...
#     @property
#     def circular(self): ...
#     @circular.setter
#     def circular(self, circular: Any) -> None: ...
#     def copy(self, points: Optional[Any] = ..., bounds: Optional[Any] = ...): ...
#     def __eq__(self, other: Any) -> Any: ...
#     __hash__: Any = ...
#     def __getitem__(self, key: Any): ...
#     def collapsed(self, dims_to_collapse: Optional[Any] = ...): ...
#     def bounds(self, bounds: Any) -> None: ...
#     def is_monotonic(self): ...
#     def xml_element(self, doc: Any): ...

class AuxCoord(Coord): ...
#     def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class CellMethod(iris.util._OrderedHashable): ...
#     method: Any = ...
#     coord_names: Any = ...
#     intervals: Any = ...
#     comments: Any = ...
#     def __init__(self, method: Any, coords: Optional[Any] = ..., intervals: Optional[Any] = ..., comments: Optional[Any] = ...): ...
#     def __add__(self, other: Any) -> None: ...
#     def xml_element(self, doc: Any): ...

# class _CellIterator(Iterator): ...
# #     def __init__(self, coord: Any) -> None: ...
# #     def __next__(self): ...
# #     next: Any = ...

# class _GroupIterator(Iterator): ...
# #     def __init__(self, points: Any) -> None: ...
# #     def __next__(self): ...
# #     next: Any = ...
