import abc
from cube import LazyData, OneOrMany, RealData, StrOr
from cf_units import Unit
import iris.util
from abc import ABCMeta, abstractmethod
from collections import namedtuple
from collections.abc import Iterator
from iris._data_manager import DataManager as DataManager
from iris.common import AncillaryVariableMetadata as AncillaryVariableMetadata, BaseMetadata as BaseMetadata, CFVariableMixin as CFVariableMixin, CellMeasureMetadata as CellMeasureMetadata, CoordMetadata as CoordMetadata, DimCoordMetadata as DimCoordMetadata, metadata_manager_factory as metadata_manager_factory
from typing import Any, Iterable, Literal, Mapping, NoReturn, Optional, Tuple, Type, TypeVar, Union, overload
from iris.cube import Cube
from numpy.typing import ArrayLike
import numpy as np
import xml.dom.minidom

from iris.coord_systems import CoordSystem

T = TypeVar("T")
C = TypeVar("C", bound="_DimensionalMetadata")
CellMeasureType = Literal["area", "volume"]

class _DimensionalMetadata(CFVariableMixin, metaclass=ABCMeta):
    standard_name: str = ...
    long_name: str = ...
    var_name: str = ...
    units: Unit = ...
    attributes: dict[str, Any] = ...
    @abstractmethod
    def __init__(self, values: ArrayLike, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., attributes: Optional[dict[str, Any]] = ...) -> None: ...
    def __getitem__(self:C , keys: Any) -> C: ...
    def copy(self: C, values: Optional[ArrayLike] = ...) -> C: ...
    @abstractmethod
    def cube_dims(self, cube: Cube) -> Optional[Tuple[int, ...]]: ...
#     def __eq__(self, other: Any) -> Any: ...
#     def __ne__(self, other: Any) -> Any: ...
#     def __hash__(self) -> Any: ...
#     def __binary_operator__(self, other: Any, mode_constant: Any): ...
#     def __add__(self, other: Any): ...
#     def __sub__(self, other: Any): ...
#     def __mul__(self, other: Any): ...
#     def __div__(self, other: Any): ...
#     def __truediv__(self, other: Any): ...
#     def __radd__(self, other: Any): ...
#     def __rsub__(self, other: Any): ...
#     def __rdiv__(self, other: Any): ...
#     def __rtruediv__(self, other: Any): ...
#     def __rmul__(self, other: Any): ...
#     def __neg__(self): ...
    bounds: Any = ...
    def convert_units(self, unit: StrOr[Unit]) -> None: ...
    def is_compatible(self, other: _DimensionalMetadata, ignore: Optional[OneOrMany[str]] = ...) -> bool: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def ndim(self) -> int: ...
    def has_bounds(self) -> bool: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    def xml_element(self, doc: xml.dom.minidom.Document) -> xml.dom.minidom.Element: ...

class AncillaryVariable(_DimensionalMetadata):
    def __init__(self, data: ArrayLike, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., attributes: Optional[Mapping[str, Any]] = ...) -> None: ...
    @property
    def data(self) -> ArrayLike: ...
    @data.setter
    def data(self, data: ArrayLike) -> None: ...
    def lazy_data(self) -> LazyData: ...
    def core_data(self) -> RealData: ...
    def has_lazy_data(self) -> bool: ...
    def cube_dims(self, cube: Cube) -> Tuple[int, ...]: ...

class CellMeasure(AncillaryVariable): 
    def __init__(self, data: ArrayLike, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., attributes: Optional[Mapping[str, Any]] = ..., measure: Optional[CellMeasureType] = ...) -> None: ...
    @property
    def measure(self) -> CellMeasureType: ...
    @measure.setter
    def measure(self, measure: CellMeasureType) -> None: ...
    def cube_dims(self, cube: Cube) -> Tuple[int, ...]: ...

class CoordExtent:
    def __new__(cls: Type[T], name_or_coord: StrOr[Coord], minimum: float, maximum: float, min_inclusive: bool = ..., max_inclusive: bool = ...) -> T: ...

# POINT_MODE: int
# BOUND_MODE: int
# BOUND_POSITION_START: int
# BOUND_POSITION_MIDDLE: float
# BOUND_POSITION_END: int

# _GroupbyItem = namedtuple('GroupbyItem', 'groupby_point, groupby_slice')

class Cell:
#     __array_priority__: int = ...
    def __new__(cls, point: Optional[OneOrMany[float]] = ..., bound: Optional[Iterable[float]] = ...): ...
    def __mod__(self, mod: float) -> Cell: ...
    def __add__(self, mod: float) -> Cell: ...
#     def __hash__(self) -> Any: ...
#     def __eq__(self, other: Any) -> Any: ...
#     def __ne__(self, other: Any) -> Any: ...
#     def __common_cmp__(self, other: Any, operator_method: Any): ...
#     def __ge__(self, other: Any) -> Any: ...
#     def __le__(self, other: Any) -> Any: ...
#     def __gt__(self, other: Any) -> Any: ...
#     def __lt__(self, other: Any) -> Any: ...
    def contains_point(self, point: Any) -> bool: ...

class Coord(_DimensionalMetadata, metaclass=abc.ABCMeta):
    @abstractmethod
    def __init__(self, points: Any, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., bounds: Optional[Any] = ..., attributes: Optional[Any] = ..., coord_system: Optional[CoordSystem] = ..., climatological: bool = ...) -> None: ...
    def copy(self: T, points: Optional[ArrayLike] = ..., bounds: Optional[ArrayLike] = ...) -> T: ...
    @classmethod
    def from_coord(cls: Type[T], coord: Coord) -> T: ...
    @property
    def points(self) -> np.ndarray: ...
    @points.setter
    def points(self, points: np.ndarray) -> None: ...
    @property
    def bounds(self) -> Optional[np.ndarray]: ...
    @bounds.setter
    def bounds(self, bounds: Optional[np.ndarray]) -> None: ...
    @property
    def coord_system(self) -> CoordSystem: ...
    @coord_system.setter
    def coord_system(self, value: CoordSystem) -> None: ...
    @property
    def climatological(self) -> bool: ...
    @climatological.setter
    def climatological(self, value: bool) -> None: ...
    def lazy_points(self) -> LazyData: ...
    def lazy_bounds(self) -> LazyData: ...
    def core_points(self) -> RealData: ...
    def core_bounds(self) -> RealData: ...
    def has_lazy_points(self) -> bool: ...
    def has_lazy_bounds(self) -> bool: ...
    def __hash__(self) -> int: ...
    def cube_dims(self, cube: Cube) -> Tuple[int, ...]: ...
    def convert_units(self, unit: StrOr[Unit]) -> None: ...
    def cells(self) -> Iterable[Cell]: ...
    def is_contiguous(self, rtol: float = ..., atol: float = ...) -> bool: ...
    def contiguous_bounds(self) -> np.ndarray: ...
    def is_monotonic(self) -> bool: ...
    def is_compatible(self, other: _DimensionalMetadata, ignore: Optional[OneOrMany[str]] = ...) -> bool: ...
    @property
    def bounds_dtype(self) -> np.dtype: ...
    @property
    def nbounds(self) -> int: ...
    def has_bounds(self) -> bool: ...
    def cell(self, index: int) -> Cell: ...
    def collapsed(self: C, dims_to_collapse: Optional[OneOrMany[int]] = ...) -> C: ...
    def guess_bounds(self, bound_position: float = ...) -> None: ...
    @overload
    def intersect(self, other: Union[Coord, CoordMetadata, DimCoordMetadata], return_indices: Literal[True] = ...) -> np.ndarray: ...
    @overload
    def intersect(self: C, other: Union[Coord, CoordMetadata, DimCoordMetadata], return_indices: Literal[False]) -> C: ...
    def nearest_neighbour_index(self, point: int): ...
#     def xml_element(self, doc: Any): ...

class DimCoord(Coord):
    @classmethod
    def from_regular(cls, zeroth: float, step: float, count: int, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., attributes: Optional[dict[str, Any]] = ..., coord_system: Optional[CoordSystem] = ..., circular: bool = ..., climatological: bool = ..., with_bounds: bool = ...) -> DimCoord: ...
    def __init__(self, points: ArrayLike, standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ..., units: Optional[StrOr[Unit]] = ..., bounds: Optional[ArrayLike] = ..., attributes: Optional[dict[str, Any]] = ..., coord_system: Optional[CoordSystem] = ..., circular: bool = ..., climatological: bool = ...) -> None: ...
#     def __deepcopy__(self, memo: Any): ...
    @property
    def circular(self) -> bool: ...
    @circular.setter
    def circular(self, circular: bool) -> None: ...
#     def copy(self, points: Optional[Any] = ..., bounds: Optional[Any] = ...): ...
#     def __eq__(self, other: Any) -> Any: ...
#     __hash__: Any = ...
#     def __getitem__(self, key: Any): ...
#     def collapsed(self, dims_to_collapse: Optional[Any] = ...): ...
#     def bounds(self, bounds: Any) -> None: ...
#     def is_monotonic(self): ...
#     def xml_element(self, doc: Any): ...

class AuxCoord(Coord):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class CellMethod(iris.util._OrderedHashable):
    method: Optional[str]
    coord_names: Optional[list[str]]
    intervals: Optional[list[str]]
    comments: Optional[list[str]]
    def __init__(self, method: str, coords: Optional[OneOrMany[StrOr[Coord]]] = ..., intervals: Optional[OneOrMany[str]] = ..., comments: Optional[OneOrMany[str]] = ...): ...
    def __add__(self, other: Any) -> NoReturn: ...
    def xml_element(self, doc: xml.dom.minidom.Document) -> xml.dom.minidom.Element: ...

# class _CellIterator(Iterator): ...
# #     def __init__(self, coord: Any) -> None: ...
# #     def __next__(self): ...
# #     next: Any = ...

# class _GroupIterator(Iterator): ...
# #     def __init__(self, points: Any) -> None: ...
# #     def __next__(self): ...
# #     next: Any = ...
