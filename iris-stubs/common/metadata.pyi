from abc import ABCMeta
import fnmatch
from typing import Any, Callable, Mapping, Optional, Tuple, Type, TypeVar, Union

T = TypeVar('T')
# EQ_TYPE = Union[NotImplemented, bool]

class _NamedTupleMeta(ABCMeta):
    def __new__(mcs: Any, name: Any, bases: Any, namespace: Any): ...

class BaseMetadata(metaclass=_NamedTupleMeta):
    DEFAULT_NAME: str = ...
    def __eq__(self , other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def combine(self: T, other: T, lenient: Optional[bool] = ...) -> T: ...
    def difference(self: T, other: T, lenient: Optional[bool] = ...) -> Optional[T]: ...
    def equal(self: T, other: T, lenient: Optional[Any] = ...) -> bool: ...
    @classmethod
    def from_metadata(cls: T, other: BaseMetadata) -> T: ...
    def name(self, default: Optional[str] = ..., token: bool = ...) -> str: ...
    @classmethod
    def token(cls, name: str) -> Optional[str]: ...

class AncillaryVariableMetadata(BaseMetadata): ...
class CellMeasureMetadata(BaseMetadata): ...
class CoordMetadata(BaseMetadata): ...
class DimCoordMetadata(CoordMetadata): ...
class CubeMetadata(BaseMetadata):
    attributes: Mapping[str, Any] = ...



# this return type is not strictly true due to runtime compilation
# of a bespoke class from the factory
def metadata_manager_factory(cls: Type[T], **kwargs: Any) -> T: ...  

# fn = Tuple[BaseMetadata, Callable[[T, T, Optional[bool]], T]]
# SERVICES_COMBINE: fn
# SERVICES_DIFFERENCE: fn
# SERVICES_EQUAL: fn
# SERVICES: fn
