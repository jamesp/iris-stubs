from collections.abc import Iterator, MutableMapping

from typing import Any, Iterable, Literal, Mapping, Optional, Tuple, TypeVar, Union, overload

from cf_units import Unit

from iris.coords import CellMeasure, CellMethod, DimCoord, AuxCoord, Coord, AncillaryVariable, CoordExtent
from iris.coord_systems import CoordSystem
from iris.common import CFVariableMixin, CubeMetadata
from iris.aux_factory import AuxCoordFactory
from iris._constraints import Constraint
from iris.analysis import Aggregator, Linear, Nearest, AreaWeighted, UnstructuredNearest, PointInCell

from numpy.typing import DTypeLike, ArrayLike


T = TypeVar("T")
OneOrMany = Union[T, Iterable[T]]
StrOr = Union[str, T]  # for functions that take name or object with name

# TODO: Replace with proper types
RealData = ArrayLike
LazyData = ArrayLike
RealOrLazyData = Union[RealData, LazyData]

AxisType = Literal["X", "Y", "Z", "T"]
Interpolator = Union[Linear, Nearest]
Regridder = Union[Linear, Nearest, AreaWeighted, UnstructuredNearest, PointInCell]
class _CubeFilter:
    constraint:  Constraint
    cubes: CubeList
    def __init__(self, constraint: Constraint, cubes: Optional[CubeList] = ...) -> None: ...
    def __len__(self) -> int: ...
    def add(self, cube: Cube) -> None: ...
    def merged(self, unique: bool = ...) -> _CubeFilter: ...

class _CubeFilterCollection:
    @staticmethod
    def from_cubes(cubes: Iterable[Cube], constraints: Optional[OneOrMany[Constraint]] = ...) -> _CubeFilterCollection: ...
    pairs: list[_CubeFilter]
    def __init__(self, pairs: Iterable[_CubeFilter]) -> None: ...
    def add_cube(self, cube: Cube) -> None: ...
    def cubes(self): ...
    def merged(self, unique: bool = ...) -> _CubeFilterCollection: ...

class CubeList(list):
    
    @staticmethod
    def _extract_and_merge(
        cubes: Iterable[Cube], 
        constraints: OneOrMany[Constraint], strict:bool=False, return_single_cube:bool=False
    ) -> CubeList: ...
    def __new__(cls, list_of_cubes: Optional[Iterable[Cube]]=None): ...
    def __add__(self, other: Any): ...

    @overload
    def __getitem__(self, keys: int) -> Cube: ...
    @overload
    def __getitem__(self, keys: slice) -> CubeList: ...

    def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...) -> str: ...
    def extract(self, constraints: Iterable[Constraint]) -> CubeList: ...
    def extract_cube(self, constraint: Constraint) -> Cube: ...
    def extract_cubes(self, constraints: Any): ...
    def extract_overlapping(self, coord_names: OneOrMany[str]) -> CubeList: ...
    def merge_cube(self) -> Cube: ...
    def merge(self, unique: bool = ...) -> CubeList: ...
    def concatenate_cube(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...) -> Cube: ...
    def concatenate(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...) -> CubeList: ...
    def realise_data(self) -> None: ...

class Cube(CFVariableMixin):
    __orthogonal_indexing__: bool = ...
    standard_name: str = ...
    units: Unit = ...
    long_name: str = ...
    var_name: str = ...
    attributes: dict[str, Any] = ...

    def __init__(self, 
        data: Any, 
        standard_name: Optional[str] = ..., 
        long_name: Optional[str] = ...,
        var_name: Optional[str] = ...,
        units: Optional[str] = ...,
        attributes: Optional[dict[str, Any]] = ..., 
        cell_methods: Optional[Iterable[CellMethod]] = ..., 
        dim_coords_and_dims: Optional[Iterable[Tuple[DimCoord, int]]] = ...,
        aux_coords_and_dims: Optional[Iterable[Tuple[AuxCoord, int]]] = ...,
        aux_factories: Optional[Iterable[AuxCoordFactory]] = ...,
        cell_measures_and_dims: Optional[Iterable[Tuple[CellMethod, int]]] = ...,
        ancillary_variables_and_dims: Optional[Iterable[Tuple[AncillaryVariable, int]]] = ...
    ) -> None: ...

    def is_compatible(self, 
        other: Union[Cube, CubeMetadata], 
        ignore: Optional[Union[str, Iterable[str]]] = ...) -> bool: ...

    def convert_units(self, unit: str): ...
    def add_cell_method(self, cell_method: CellMethod) -> None: ...
    def add_aux_coord(self, coord: AuxCoord, data_dims: Optional[Any] = ...) -> None: ...
    def add_aux_factory(self, aux_factory: AuxCoordFactory) -> None: ...
    def add_cell_measure(self, cell_measure: CellMeasure, data_dims: Optional[Union[int, Iterable[int]]] = ...): ...
    def add_ancillary_variable(self, 
        ancillary_variable: AncillaryVariable, 
        data_dims: Optional[Union[int, Iterable[int]]] = ...): ...
    def add_dim_coord(self, dim_coord: DimCoord, data_dim: int) -> None: ...
    def remove_aux_factory(self, aux_factory: AuxCoordFactory) -> None: ...
    def remove_coord(self, coord: StrOr[Coord]) -> None: ...
    def remove_cell_measure(self, cell_measure: StrOr[CellMeasure]) -> None: ...
    def remove_ancillary_variable(self, ancillary_variable: StrOr[AncillaryVariable]) -> None: ...
    def replace_coord(self, new_coord: Coord) -> None: ...
    def coord_dims(self, coord: StrOr[Coord] ): ...
    def cell_measure_dims(self, cell_measure: StrOr[CellMeasure]): ...
    def ancillary_variable_dims(self, ancillary_variable: StrOr[AncillaryVariable]) -> Tuple[int, ...]: ...
    def aux_factory(self, name: Optional[str] = ..., standard_name: Optional[str] = ..., long_name: Optional[str] = ..., var_name: Optional[str] = ...) -> AuxCoordFactory: ...
    def coords(self, 
        name_or_coord: Optional[StrOr[Coord]] = ..., 
        standard_name: Optional[str] = ..., 
        long_name: Optional[str] = ..., 
        var_name: Optional[str] = ..., 
        attributes: Optional[Mapping[str, Any]] = ..., 
        axis: Optional[AxisType] = ..., 
        contains_dimension: Optional[int] = ..., 
        dimensions: Optional[Any] = ..., 
        coord_system: Optional[CoordSystem] = ..., 
        dim_coords: Optional[Any] = ...) -> list[Coord]: ...
    def coord(self, 
        name_or_coord: Optional[StrOr[Coord]] = ..., 
        standard_name: Optional[str] = ..., 
        long_name: Optional[str] = ..., 
        var_name: Optional[str] = ..., 
        attributes: Optional[Any] = ..., 
        axis: Optional[Any] = ..., 
        contains_dimension: Optional[Any] = ..., 
        dimensions: Optional[Any] = ..., 
        coord_system: Optional[Any] = ..., 
        dim_coords: Optional[Any] = ...) -> Coord: ...
    def coord_system(self, spec: Optional[StrOr[CoordSystem]] = ...) -> Optional[CoordSystem]: ...
    def cell_measures(self, name_or_cell_measure: Optional[StrOr[CellMeasure]] = ...) -> list[CellMeasure]: ...
    def cell_measure(self, name_or_cell_measure: Optional[StrOr[CellMeasure]] = ...) -> CellMeasure: ...
    def ancillary_variables(self, name_or_ancillary_variable: Optional[StrOr[AncillaryVariable]] = ...) -> list[AncillaryVariable]: ...
    def ancillary_variable(self, name_or_ancillary_variable: Optional[StrOr[AncillaryVariable]] = ...) -> AncillaryVariable: ...
    @property
    def cell_methods(self) -> Tuple[CellMethod, ...]: ...
    @cell_methods.setter
    def cell_methods(self, cell_methods: OneOrMany[CellMethod]) -> None: ... # type: ignore
    def core_data(self) -> RealOrLazyData: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def dtype(self) -> DTypeLike: ...
    @property
    def ndim(self) -> int: ...
    def lazy_data(self) -> LazyData: ...
    @property
    def data(self) -> RealData: ...
    @data.setter
    def data(self, data: RealData) -> None: ...
    def has_lazy_data(self) -> bool: ...
    @property
    def dim_coords(self) -> Tuple[DimCoord, ...]: ...
    @property
    def aux_coords(self) -> Tuple[AuxCoord, ...]: ...
    @property
    def derived_coords(self) -> Tuple[Coord, ...]: ...
    @property
    def aux_factories(self) -> Tuple[AuxCoordFactory, ...]: ...
    def summary(self, shorten: bool = ..., name_padding: int = ...) -> str: ...
    # def __unicode__(self): ...
    __iter__ = None
    def __getitem__(self, keys: Any) -> Cube: ...  # TODO: determine actual allowed indexes
    def subset(self, coord: StrOr[Coord]) -> Optional[Cube]: ...
    def extract(self, constraint: StrOr[Constraint]) -> Optional[Cube]: ...
    def intersection(self, *args: list[CoordExtent], **kwargs: dict[str, Tuple[float, ...]]): ...
    def slices_over(self, ref_to_slice: Any): ...
    def slices(self, ref_to_slice: Any, ordered: bool = ...): ...
    def transpose(self, new_order: Optional[Iterable[int]] = ...) -> None: ...
    def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...) -> str: ...
    def copy(self, data: Optional[Any] = ...): ...
    def __copy__(self) -> None: ...
    def __deepcopy__(self, memo: Any) -> Cube: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    # def __add__(self, other: Any): ...
    # def __iadd__(self, other: Any): ...
    # __radd__: Any = ...
    def __sub__(self, other: Any) -> Cube: ...
    def __isub__(self, other: Any) -> Cube: ...
    # # __mul__: Any = ...
    # # __rmul__: Any = ...
    # # def __imul__(self, other: Any): ...
    # # __div__: Any = ...
    # # def __idiv__(self, other: Any): ...
    # # __truediv__: Any = ...
    # # def __itruediv__(self, other: Any): ...
    # # __pow__: Any = ...
    def collapsed(self, coords: OneOrMany[StrOr[Coord]], aggregator: Aggregator, **kwargs: Any) -> Cube: ...
    def aggregated_by(self, coords: OneOrMany[StrOr[Coord]], aggregator: Aggregator, **kwargs: Any) -> Cube: ...
    def rolling_window(self, coord: StrOr[Coord], aggregator: Aggregator, window: int, **kwargs: Any) -> Cube: ...
    def interpolate(self, sample_points: Iterable[Tuple[StrOr[Coord], float]], scheme: Interpolator, collapse_scalar: bool = ...) -> Cube: ...
    def regrid(self, grid: Cube, scheme: Regridder) -> Cube: ...

class ClassDict(MutableMapping):
    def __init__(self, superclass: Any) -> None: ...
    def add(self, object_: Any, replace: bool = ...) -> None: ...
    def __getitem__(self, class_: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, class_: Any): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def keys(self): ...

# class _SliceIterator(Iterator):
#     def __init__(self, cube: Any, dims_index: Any, requested_dims: Any, ordered: Any) -> None: ...
#     #def __next__(self): ...
#     #next: Any = ...
