from collections.abc import Iterator, MutableMapping
from iris._constraints import Constraint
from iris.coords import AncillaryVariable, CellMeasure, Coord
from typing import Any, Iterable, Optional, Tuple, Union, overload

from cf_units import Unit

from iris.coords import CellMeasure, CellMethod, DimCoord, AuxCoord, Coord, AncillaryVariable
from iris.coord_systems import CoordSystem
from iris.common import CFVariableMixin, CubeMetadata
from iris.aux_factory import AuxCoordFactory

class _CubeFilter: ...
    # constraint: Any = ...
    # cubes: Any = ...
    # def __init__(self, constraint: Any, cubes: Optional[Any] = ...) -> None: ...
    # def __len__(self): ...
    # def add(self, cube: Any) -> None: ...
    # def merged(self, unique: bool = ...): ...

class _CubeFilterCollection: ...
    # @staticmethod
    # def from_cubes(cubes: Any, constraints: Optional[Any] = ...): ...
    # pairs: Any = ...
    # def __init__(self, pairs: Any) -> None: ...
    # def add_cube(self, cube: Any) -> None: ...
    # def cubes(self): ...
    # def merged(self, unique: bool = ...): ...

class CubeList(list):
    def __new__(cls, list_of_cubes: Iterable[Cube] = ...): ...
    # def __add__(self, other: Any): ...
    # 
    # @overload
    # def __getitem__(self, keys: Iterable[int]) -> CubeList: ...
    # @overload
    # def __getitem__(self, keys: int) -> Cube: ...
    # def __getslice__(self, start: Any, stop: Any): ...
    # def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...): ...
    # def extract(self, constraints: Any): ...
    def extract_cube(self, constraint: Constraint) -> Cube: ...
    # def extract_cubes(self, constraints: Any): ...
    # def extract_overlapping(self, coord_names: Any): ...
    # def merge_cube(self): ...
    # def merge(self, unique: bool = ...): ...
    # def concatenate_cube(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...): ...
    # def concatenate(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...): ...
    # def realise_data(self) -> None: ...

class Cube(CFVariableMixin):
    __orthogonal_indexing__: bool = ...
    standard_name: str = ...
    units: Unit = ...
    long_name: str = ...
    var_name: str = ...
    attributes: dict[str, Any] = ...

    def __init__(self, 
        data: Any, 
        standard_name: Optional[str] = ..., 
        long_name: Optional[str] = ...,
        var_name: Optional[str] = ...,
        units: Optional[str] = ...,
        attributes: Optional[dict[str, Any]] = ..., 
        cell_methods: Optional[Iterable[CellMethod]] = ..., 
        dim_coords_and_dims: Optional[Iterable[Tuple[DimCoord, int]]] = ...,
        aux_coords_and_dims: Optional[Iterable[Tuple[AuxCoord, int]]] = ...,
        aux_factories: Optional[Iterable[AuxCoordFactory]] = ...,
        cell_measures_and_dims: Optional[Iterable[Tuple[CellMethod, int]]] = ...,
        ancillary_variables_and_dims: Optional[Iterable[Tuple[AncillaryVariable, int]]] = ...
    ) -> None: ...

    def is_compatible(self, 
        other: Union[Cube, CubeMetadata], 
        ignore: Optional[Union[str, Iterable[str]]] = ...) -> bool: ...

    def convert_units(self, unit: str): ...
    def add_cell_method(self, cell_method: CellMethod) -> None: ...
    def add_aux_coord(self, coord: AuxCoord, data_dims: Optional[Any] = ...) -> None: ...
    def add_aux_factory(self, aux_factory: AuxCoordFactory) -> None: ...
    def add_cell_measure(self, cell_measure: CellMeasure, data_dims: Optional[Union[int, Iterable[int]]] = ...): ...
    def add_ancillary_variable(self, 
        ancillary_variable: AncillaryVariable, 
        data_dims: Optional[Union[int, Iterable[int]]] = ...): ...
    def add_dim_coord(self, dim_coord: DimCoord, data_dim: int) -> None: ...
    def remove_aux_factory(self, aux_factory: AuxCoordFactory) -> None: ...
    def remove_coord(self, coord: Union[str, Coord]) -> None: ...
    def remove_cell_measure(self, cell_measure: Union[str, CellMeasure]) -> None: ...
    def remove_ancillary_variable(self, ancillary_variable: Union[str, AncillaryVariable]) -> None: ...
    # def replace_coord(self, new_coord: Any) -> None: ...
    # def coord_dims(self, coord: Any): ...
    # def cell_measure_dims(self, cell_measure: Any): ...
    # def ancillary_variable_dims(self, ancillary_variable: Any): ...
    # def aux_factory(self, name: Optional[Any] = ..., standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ...): ...
    # def coords(self, name_or_coord: Optional[Any] = ..., standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., attributes: Optional[Any] = ..., axis: Optional[Any] = ..., contains_dimension: Optional[Any] = ..., dimensions: Optional[Any] = ..., coord_system: Optional[Any] = ..., dim_coords: Optional[Any] = ...): ...
    def coord(self, 
        name_or_coord: Optional[Union[Coord, str]] = ..., 
        standard_name: Optional[Any] = ..., 
        long_name: Optional[Any] = ..., 
        var_name: Optional[Any] = ..., 
        attributes: Optional[Any] = ..., 
        axis: Optional[Any] = ..., 
        contains_dimension: Optional[Any] = ..., 
        dimensions: Optional[Any] = ..., 
        coord_system: Optional[Any] = ..., 
        dim_coords: Optional[Any] = ...) -> Coord: ...
    # def coord_system(self, spec: Optional[Any] = ...) -> Optional[CoordSystem]: ...
    # def cell_measures(self, name_or_cell_measure: Optional[Any] = ...): ...
    # def cell_measure(self, name_or_cell_measure: Optional[Any] = ...): ...
    # def ancillary_variables(self, name_or_ancillary_variable: Optional[Any] = ...): ...
    # def ancillary_variable(self, name_or_ancillary_variable: Optional[Any] = ...): ...
    # @property
    # def cell_methods(self) -> Tuple[CellMethod, int]: ...
    # @cell_methods.setter
    # def cell_methods(self, cell_methods: Any) -> None: ...
    # def core_data(self): ...
    # @property
    # def shape(self): ...
    # @property
    # def dtype(self): ...
    # @property
    # def ndim(self): ...
    # def lazy_data(self): ...
    # @property
    # def data(self): ...
    # @data.setter
    # def data(self, data: Any) -> None: ...
    # def has_lazy_data(self): ...
    # @property
    # def dim_coords(self) -> Tuple[DimCoord, int]: ...
    # @property
    # def aux_coords(self) -> Tuple[AuxCoord, int]: ...
    # @property
    # def derived_coords(self): ...
    # @property
    # def aux_factories(self): ...
    # def summary(self, shorten: bool = ..., name_padding: int = ...) -> str: ...
    # # def __unicode__(self): ...
    # __iter__: Any = ...
    # def __getitem__(self, keys: Any) -> Cube: ...
    # def subset(self, coord: Any): ...
    # def extract(self, constraint: Any): ...
    # def intersection(self, *args: Any, **kwargs: Any): ...
    # def slices_over(self, ref_to_slice: Any): ...
    # def slices(self, ref_to_slice: Any, ordered: bool = ...): ...
    # def transpose(self, new_order: Optional[Iterable[int]] = ...) -> None: ...
    # def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...) -> str: ...
    # def copy(self, data: Optional[Any] = ...): ...
    # def __copy__(self) -> None: ...
    # def __deepcopy__(self, memo: Any) -> Cube: ...
    # def __eq__(self, other: Any) -> bool: ...
    # def __ne__(self, other: Any) -> Any: ...
    # def __hash__(self) -> Any: ...
    # # def __add__(self, other: Any): ...
    # # def __iadd__(self, other: Any): ...
    # # __radd__: Any = ...
    # # def __sub__(self, other: Any): ...
    # # def __isub__(self, other: Any): ...
    # # __mul__: Any = ...
    # # __rmul__: Any = ...
    # # def __imul__(self, other: Any): ...
    # # __div__: Any = ...
    # # def __idiv__(self, other: Any): ...
    # # __truediv__: Any = ...
    # # def __itruediv__(self, other: Any): ...
    # # __pow__: Any = ...
    # def collapsed(self, coords: Any, aggregator: Any, **kwargs: Any): ...
    # def aggregated_by(self, coords: Any, aggregator: Any, **kwargs: Any): ...
    # def rolling_window(self, coord: Any, aggregator: Any, window: Any, **kwargs: Any): ...
    # def interpolate(self, sample_points: Any, scheme: Any, collapse_scalar: bool = ...): ...
    # def regrid(self, grid: Any, scheme: Any): ...

class ClassDict(MutableMapping):
    def __init__(self, superclass: Any) -> None: ...
    def add(self, object_: Any, replace: bool = ...) -> None: ...
    def __getitem__(self, class_: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, class_: Any): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def keys(self): ...

# class _SliceIterator(Iterator):
#     def __init__(self, cube: Any, dims_index: Any, requested_dims: Any, ordered: Any) -> None: ...
#     #def __next__(self): ...
#     #next: Any = ...
