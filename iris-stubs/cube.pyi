from collections.abc import Iterator, MutableMapping
from iris.common import CFVariableMixin
from typing import Any, Optional

class _CubeFilter:
    constraint: Any = ...
    cubes: Any = ...
    def __init__(self, constraint: Any, cubes: Optional[Any] = ...) -> None: ...
    def __len__(self): ...
    def add(self, cube: Any) -> None: ...
    def merged(self, unique: bool = ...): ...

class _CubeFilterCollection:
    @staticmethod
    def from_cubes(cubes: Any, constraints: Optional[Any] = ...): ...
    pairs: Any = ...
    def __init__(self, pairs: Any) -> None: ...
    def add_cube(self, cube: Any) -> None: ...
    def cubes(self): ...
    def merged(self, unique: bool = ...): ...

class CubeList(list):
    def __new__(cls, list_of_cubes: Optional[Any] = ...): ...
    def __add__(self, other: Any): ...
    def __getitem__(self, keys: Any): ...
    def __getslice__(self, start: Any, stop: Any): ...
    def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...): ...
    def extract(self, constraints: Any): ...
    def extract_cube(self, constraint: Any): ...
    def extract_cubes(self, constraints: Any): ...
    def extract_overlapping(self, coord_names: Any): ...
    def merge_cube(self): ...
    def merge(self, unique: bool = ...): ...
    def concatenate_cube(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...): ...
    def concatenate(self, check_aux_coords: bool = ..., check_cell_measures: bool = ..., check_ancils: bool = ...): ...
    def realise_data(self) -> None: ...

class Cube(CFVariableMixin):
    __orthogonal_indexing__: bool = ...
    standard_name: Any = ...
    units: Any = ...
    long_name: Any = ...
    var_name: Any = ...
    attributes: Any = ...
    def __init__(self, data: Any, standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., units: Optional[Any] = ..., attributes: Optional[Any] = ..., cell_methods: Optional[Any] = ..., dim_coords_and_dims: Optional[Any] = ..., aux_coords_and_dims: Optional[Any] = ..., aux_factories: Optional[Any] = ..., cell_measures_and_dims: Optional[Any] = ..., ancillary_variables_and_dims: Optional[Any] = ...) -> None: ...
    def is_compatible(self, other: Any, ignore: Optional[Any] = ...): ...
    def convert_units(self, unit: Any): ...
    def add_cell_method(self, cell_method: Any) -> None: ...
    def add_aux_coord(self, coord: Any, data_dims: Optional[Any] = ...) -> None: ...
    def add_aux_factory(self, aux_factory: Any) -> None: ...
    def add_cell_measure(self, cell_measure: Any, data_dims: Optional[Any] = ...): ...
    def add_ancillary_variable(self, ancillary_variable: Any, data_dims: Optional[Any] = ...): ...
    def add_dim_coord(self, dim_coord: Any, data_dim: Any) -> None: ...
    def remove_aux_factory(self, aux_factory: Any) -> None: ...
    def remove_coord(self, coord: Any) -> None: ...
    def remove_cell_measure(self, cell_measure: Any) -> None: ...
    def remove_ancillary_variable(self, ancillary_variable: Any) -> None: ...
    def replace_coord(self, new_coord: Any) -> None: ...
    def coord_dims(self, coord: Any): ...
    def cell_measure_dims(self, cell_measure: Any): ...
    def ancillary_variable_dims(self, ancillary_variable: Any): ...
    def aux_factory(self, name: Optional[Any] = ..., standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ...): ...
    def coords(self, name_or_coord: Optional[Any] = ..., standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., attributes: Optional[Any] = ..., axis: Optional[Any] = ..., contains_dimension: Optional[Any] = ..., dimensions: Optional[Any] = ..., coord_system: Optional[Any] = ..., dim_coords: Optional[Any] = ...): ...
    def coord(self, name_or_coord: Optional[Any] = ..., standard_name: Optional[Any] = ..., long_name: Optional[Any] = ..., var_name: Optional[Any] = ..., attributes: Optional[Any] = ..., axis: Optional[Any] = ..., contains_dimension: Optional[Any] = ..., dimensions: Optional[Any] = ..., coord_system: Optional[Any] = ..., dim_coords: Optional[Any] = ...): ...
    def coord_system(self, spec: Optional[Any] = ...): ...
    def cell_measures(self, name_or_cell_measure: Optional[Any] = ...): ...
    def cell_measure(self, name_or_cell_measure: Optional[Any] = ...): ...
    def ancillary_variables(self, name_or_ancillary_variable: Optional[Any] = ...): ...
    def ancillary_variable(self, name_or_ancillary_variable: Optional[Any] = ...): ...
    @property
    def cell_methods(self): ...
    @cell_methods.setter
    def cell_methods(self, cell_methods: Any) -> None: ...
    def core_data(self): ...
    @property
    def shape(self): ...
    @property
    def dtype(self): ...
    @property
    def ndim(self): ...
    def lazy_data(self): ...
    @property
    def data(self): ...
    @data.setter
    def data(self, data: Any) -> None: ...
    def has_lazy_data(self): ...
    @property
    def dim_coords(self): ...
    @property
    def aux_coords(self): ...
    @property
    def derived_coords(self): ...
    @property
    def aux_factories(self): ...
    def summary(self, shorten: bool = ..., name_padding: int = ...): ...
    def __unicode__(self): ...
    __iter__: Any = ...
    def __getitem__(self, keys: Any): ...
    def subset(self, coord: Any): ...
    def extract(self, constraint: Any): ...
    def intersection(self, *args: Any, **kwargs: Any): ...
    def slices_over(self, ref_to_slice: Any): ...
    def slices(self, ref_to_slice: Any, ordered: bool = ...): ...
    def transpose(self, new_order: Optional[Any] = ...): ...
    def xml(self, checksum: bool = ..., order: bool = ..., byteorder: bool = ...): ...
    def copy(self, data: Optional[Any] = ...): ...
    def __copy__(self) -> None: ...
    def __deepcopy__(self, memo: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def __add__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    __radd__: Any = ...
    def __sub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    __mul__: Any = ...
    __rmul__: Any = ...
    def __imul__(self, other: Any): ...
    __div__: Any = ...
    def __idiv__(self, other: Any): ...
    __truediv__: Any = ...
    def __itruediv__(self, other: Any): ...
    __pow__: Any = ...
    def collapsed(self, coords: Any, aggregator: Any, **kwargs: Any): ...
    def aggregated_by(self, coords: Any, aggregator: Any, **kwargs: Any): ...
    def rolling_window(self, coord: Any, aggregator: Any, window: Any, **kwargs: Any): ...
    def interpolate(self, sample_points: Any, scheme: Any, collapse_scalar: bool = ...): ...
    def regrid(self, grid: Any, scheme: Any): ...

class ClassDict(MutableMapping):
    def __init__(self, superclass: Any) -> None: ...
    def add(self, object_: Any, replace: bool = ...) -> None: ...
    def __getitem__(self, class_: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, class_: Any): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def keys(self): ...

class _SliceIterator(Iterator):
    def __init__(self, cube: Any, dims_index: Any, requested_dims: Any, ordered: Any) -> None: ...
    def __next__(self): ...
    next: Any = ...
